// enumgen generates enum constants from enums.json (extracted from botocore).
//
// Usage:
//
//	go run ./cmd/enumgen
//
// This will generate enums/*.go files with constants and lookup functions.
// The enums.json file must be generated first by running:
//
//	python scripts/extract_enums.py
package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

var outputDir = flag.String("output", "enums", "output directory for generated files")

// EnumsJSON is the structure of enums.json
type EnumsJSON struct {
	Services map[string]map[string]EnumType `json:"services"`
}

// EnumType represents an enum type in the JSON
type EnumType struct {
	Name   string      `json:"name"`
	Values []EnumValue `json:"values"`
}

// EnumValue represents a single enum value
type EnumValue struct {
	Value  string `json:"value"`
	GoName string `json:"goName"`
	PyName string `json:"pyName"`
}

// priorityServices lists which services and enums to generate Go constants for.
// We don't generate for all 400+ services to keep binary size reasonable.
// Service names must match botocore service names (e.g., "elbv2" not "elasticloadbalancingv2").
var priorityServices = map[string][]string{
	"lambda": {
		"Runtime",
		"Architecture",
		"PackageType",
	},
	"ec2": {
		"VolumeType",
		// Note: InstanceType is not an enum in botocore (just strings)
	},
	"ecs": {
		"LaunchType",
		"SchedulingStrategy",
		"NetworkMode",
	},
	"s3": {
		"StorageClass",
		"ObjectCannedACL",
		"BucketCannedACL",
		"ServerSideEncryption",
		"ObjectLockRetentionMode",
		"BucketVersioningStatus",
		"Protocol",
	},
	"dynamodb": {
		"BillingMode",
		"StreamViewType",
		"TableClass",
	},
	"apigateway": {
		"IntegrationType",
	},
	"elbv2": {
		"ProtocolEnum",
		"TargetTypeEnum",
	},
	"logs": {
		"LogGroupClass",
	},
	"acm": {
		"ValidationMethod",
		"CertificateStatus",
	},
	"events": {
		"RuleState",
	},
}

// ServiceData represents data for generating a service enum file.
type ServiceData struct {
	Service     string
	ServiceName string // Capitalized service name for Go
	Enums       []EnumInfo
}

// EnumInfo represents a single enum type.
type EnumInfo struct {
	Name      string
	Constants []ConstantInfo
}

// ConstantInfo represents a single constant.
type ConstantInfo struct {
	Name  string
	Value string
}

func main() {
	flag.Parse()

	// Load enums.json
	enumsPath := filepath.Join(*outputDir, "enums.json")
	data, err := os.ReadFile(enumsPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to read %s: %v\n", enumsPath, err)
		fmt.Fprintf(os.Stderr, "hint: run 'python scripts/extract_enums.py' first\n")
		os.Exit(1)
	}

	var enums EnumsJSON
	if err := json.Unmarshal(data, &enums); err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse enums.json: %v\n", err)
		os.Exit(1)
	}

	var allServices []string
	serviceEnumNames := make(map[string][]string)

	for service, enumNames := range priorityServices {
		serviceEnums, ok := enums.Services[service]
		if !ok {
			fmt.Printf("Warning: service %s not found in enums.json\n", service)
			continue
		}

		svcData := ServiceData{
			Service:     service,
			ServiceName: capitalize(service),
		}

		for _, enumName := range enumNames {
			enumType, ok := serviceEnums[enumName]
			if !ok {
				fmt.Printf("Warning: enum %s.%s not found in enums.json\n", service, enumName)
				continue
			}

			info := EnumInfo{Name: enumName}
			for _, v := range enumType.Values {
				info.Constants = append(info.Constants, ConstantInfo{
					Name:  v.GoName,
					Value: v.Value,
				})
			}
			svcData.Enums = append(svcData.Enums, info)
			serviceEnumNames[service] = append(serviceEnumNames[service], enumName)
		}

		if len(svcData.Enums) == 0 {
			continue
		}

		allServices = append(allServices, service)

		if err := generateServiceFile(svcData); err != nil {
			fmt.Fprintf(os.Stderr, "failed to generate %s: %v\n", service, err)
			os.Exit(1)
		}
		fmt.Printf("Generated enums/%s.go\n", service)
	}

	if err := generateLookupFile(allServices, serviceEnumNames, enums); err != nil {
		fmt.Fprintf(os.Stderr, "failed to generate lookup.go: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Generated enums/lookup.go\n")
}

func capitalize(s string) string {
	if s == "" {
		return s
	}
	// Handle service names that need special casing
	switch s {
	case "ec2":
		return "Ec2"
	case "ecs":
		return "Ecs"
	case "rds":
		return "Rds"
	case "s3":
		return "S3"
	case "acm":
		return "Acm"
	default:
		return strings.ToUpper(s[:1]) + s[1:]
	}
}

const serviceTemplate = `// Code generated by enumgen from enums.json. DO NOT EDIT.

package enums

// {{.ServiceName}} enum constants
const (
{{- range .Enums}}
	// {{.Name}} values
{{- range .Constants}}
	{{.Name}} = "{{.Value}}"
{{- end}}
{{end}}
)

{{range .Enums}}
var {{$.Service}}{{.Name}}Values = []string{
{{- range .Constants}}
	"{{.Value}}",
{{- end}}
}
{{end}}

func get{{.ServiceName}}Enum(name string) []string {
	switch name {
{{- range .Enums}}
	case "{{.Name}}":
		return {{$.Service}}{{.Name}}Values
{{- end}}
	}
	return nil
}

func get{{.ServiceName}}EnumNames() []string {
	return []string{
{{- range .Enums}}
		"{{.Name}}",
{{- end}}
	}
}
`

func generateServiceFile(data ServiceData) error {
	tmpl, err := template.New("service").Parse(serviceTemplate)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Write unformatted for debugging
		formatted = buf.Bytes()
	}

	path := filepath.Join(*outputDir, data.Service+".go")
	return os.WriteFile(path, formatted, 0644)
}

const lookupTemplate = `// Code generated by enumgen from enums.json. DO NOT EDIT.

package enums

// GetAllowedValues returns valid values for a service enum.
// Returns nil if the service or enum is not found.
func GetAllowedValues(service, enumName string) []string {
	switch service {
{{- range .Services}}
	case "{{.}}":
		return get{{. | capitalize}}Enum(enumName)
{{- end}}
	}
	return nil
}

// IsValidValue checks if a value is valid for an enum.
func IsValidValue(service, enumName, value string) bool {
	values := GetAllowedValues(service, enumName)
	for _, v := range values {
		if v == value {
			return true
		}
	}
	return false
}

// GetEnumNames returns all enum names for a service.
// Returns nil if the service is not found.
func GetEnumNames(service string) []string {
	switch service {
{{- range .Services}}
	case "{{.}}":
		return get{{. | capitalize}}EnumNames()
{{- end}}
	}
	return nil
}

// Services returns the list of services with enums.
func Services() []string {
	return []string{
{{- range .Services}}
		"{{.}}",
{{- end}}
	}
}
`

type LookupData struct {
	Services []string
}

func generateLookupFile(services []string, enumNames map[string][]string, allEnums EnumsJSON) error {
	sort.Strings(services)

	funcMap := template.FuncMap{
		"capitalize": capitalize,
	}

	tmpl, err := template.New("lookup").Funcs(funcMap).Parse(lookupTemplate)
	if err != nil {
		return err
	}

	data := LookupData{Services: services}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		formatted = buf.Bytes()
	}

	path := filepath.Join(*outputDir, "lookup.go")
	return os.WriteFile(path, formatted, 0644)
}
